Syntax trees:


======= /smartbugs-curated/dataset/unchecked_low_level_calls/0x7d09edb07d23acb532a82be3da5c17d9d85806b4.sol =======
PragmaDirective
   Source: "pragma solidity ^0.4.21;"
ContractDefinition "PoCGame"
   Source: "contract PoCGame\n{\n    \n    /**\n     * Modifiers\n     */\n     \n    modifier onlyOwner()\n    {\n        require(msg.sender == owner);\n        _;\n    }\n    \n   modifier isOpenToPublic()\n    {\n        require(openToPublic);\n        _;\n    }\n\n    modifier onlyRealPeople()\n    {\n          require (msg.sender == tx.origin);\n        _;\n    }\n\n    modifier  onlyPlayers()\n    { \n        require (wagers[msg.sender] > 0); \n        _; \n    }\n    \n   \n    /**\n     * Events\n     */\n    event Wager(uint256 amount, address depositer);\n    event Win(uint256 amount, address paidTo);\n    event Lose(uint256 amount, address loser);\n    event Donate(uint256 amount, address paidTo, address donator);\n    event DifficultyChanged(uint256 currentDifficulty);\n    event BetLimitChanged(uint256 currentBetLimit);\n\n    /**\n     * Global Variables\n     */\n    address private whale;\n    uint256 betLimit;\n    uint difficulty;\n    uint private randomSeed;\n    address owner;\n    mapping(address => uint256) timestamps;\n    mapping(address => uint256) wagers;\n    bool openToPublic;\n    uint256 totalDonated;\n\n    /**\n     * Constructor\n     */\n    constructor(address whaleAddress, uint256 wagerLimit) \n    onlyRealPeople()\n    public \n    {\n        openToPublic = false;\n        owner = msg.sender;\n        whale = whaleAddress;\n        totalDonated = 0;\n        betLimit = wagerLimit;\n        \n    }\n\n\n    /**\n     * Let the public play\n     */\n    function OpenToThePublic() \n    onlyOwner()\n    public\n    {\n        openToPublic = true;\n    }\n    \n    /**\n     * Adjust the bet amounts\n     */\n    function AdjustBetAmounts(uint256 amount) \n    onlyOwner()\n    public\n    {\n        betLimit = amount;\n        \n        emit BetLimitChanged(betLimit);\n    }\n    \n     /**\n     * Adjust the difficulty\n     */\n    function AdjustDifficulty(uint256 amount) \n    onlyOwner()\n    public\n    {\n        difficulty = amount;\n        \n        emit DifficultyChanged(difficulty);\n    }\n    \n    \n    function() public payable { }\n\n    /**\n     * Wager your bet\n     */\n    function wager()\n    isOpenToPublic()\n    onlyRealPeople() \n    payable\n    public \n    {\n        //You have to send exactly 0.01 ETH.\n        require(msg.value == betLimit);\n\n        //log the wager and timestamp(block number)\n        timestamps[msg.sender] = block.number;\n        wagers[msg.sender] = msg.value;\n        emit Wager(msg.value, msg.sender);\n    }\n    \n    /**\n     * method to determine winners and losers\n     */\n    function play()\n    isOpenToPublic()\n    onlyRealPeople()\n    onlyPlayers()\n    public\n    {\n        uint256 blockNumber = timestamps[msg.sender];\n        if(blockNumber < block.number)\n        {\n            timestamps[msg.sender] = 0;\n            wagers[msg.sender] = 0;\n    \n            uint256 winningNumber = uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  msg.sender)))%difficulty +1;\n    \n            if(winningNumber == difficulty / 2)\n            {\n                payout(msg.sender);\n            }\n            else \n            {\n                //player loses\n                loseWager(betLimit / 2);\n            }    \n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    /**\n     * For those that just want to donate to the whale\n     */\n    function donate()\n    isOpenToPublic()\n    public \n    payable\n    {\n        donateToWhale(msg.value);\n    }\n\n    /**\n     * Payout ETH to winner\n     */\n    function payout(address winner) \n    internal \n    {\n        uint256 ethToTransfer = address(this).balance / 2;\n        \n        winner.transfer(ethToTransfer);\n        emit Win(ethToTransfer, winner);\n    }\n\n    /**\n     * Payout ETH to whale\n     */\n    function donateToWhale(uint256 amount) \n    internal \n    {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        whale.call.value(amount)(bytes4(keccak256(\"donate()\")));\n        totalDonated += amount;\n        emit Donate(amount, whale, msg.sender);\n    }\n\n    /**\n     * Payout ETH to whale when player loses\n     */\n    function loseWager(uint256 amount) \n    internal \n    {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        whale.call.value(amount)(bytes4(keccak256(\"donate()\")));\n        totalDonated += amount;\n        emit Lose(amount, msg.sender);\n    }\n    \n\n    /**\n     * ETH balance of contract\n     */\n    function ethBalance() \n    public \n    view \n    returns (uint256)\n    {\n        return address(this).balance;\n    }\n    \n    \n    /**\n     * current difficulty of the game\n     */\n    function currentDifficulty() \n    public \n    view \n    returns (uint256)\n    {\n        return difficulty;\n    }\n    \n    \n    /**\n     * current bet amount for the game\n     */\n    function currentBetLimit() \n    public \n    view \n    returns (uint256)\n    {\n        return betLimit;\n    }\n    \n    function hasPlayerWagered(address player)\n    public \n    view \n    returns (bool)\n    {\n        if(wagers[player] > 0)\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n        \n    }\n\n    /**\n     * For the UI to properly display the winner's pot\n     */\n    function winnersPot() \n    public \n    view \n    returns (uint256)\n    {\n        return address(this).balance / 2;\n    }\n\n    /**\n     * A trap door for when someone sends tokens other than the intended ones so the overseers can decide where to send them.\n     */\n    function transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens) \n    public \n    onlyOwner() \n    returns (bool success) \n    {\n        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n    }\n}"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner()\n    {\n        require(msg.sender == owner);\n        _;\n    }"
    ParameterList
       Source: "()"
    Block
       Source: "{\n        require(msg.sender == owner);\n        _;\n    }"
      ExpressionStatement
         Source: "require(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Source: "_"
  ModifierDefinition "isOpenToPublic"
     Source: "modifier isOpenToPublic()\n    {\n        require(openToPublic);\n        _;\n    }"
    ParameterList
       Source: "()"
    Block
       Source: "{\n        require(openToPublic);\n        _;\n    }"
      ExpressionStatement
         Source: "require(openToPublic)"
        FunctionCall
           Type: tuple()
           Source: "require(openToPublic)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          Identifier openToPublic
             Type: bool
             Source: "openToPublic"
      PlaceholderStatement
         Source: "_"
  ModifierDefinition "onlyRealPeople"
     Source: "modifier onlyRealPeople()\n    {\n          require (msg.sender == tx.origin);\n        _;\n    }"
    ParameterList
       Source: "()"
    Block
       Source: "{\n          require (msg.sender == tx.origin);\n        _;\n    }"
      ExpressionStatement
         Source: "require (msg.sender == tx.origin)"
        FunctionCall
           Type: tuple()
           Source: "require (msg.sender == tx.origin)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == tx.origin"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            MemberAccess to member origin
               Type: address
               Source: "tx.origin"
              Identifier tx
                 Type: tx
                 Source: "tx"
      PlaceholderStatement
         Source: "_"
  ModifierDefinition "onlyPlayers"
     Source: "modifier  onlyPlayers()\n    { \n        require (wagers[msg.sender] > 0); \n        _; \n    }"
    ParameterList
       Source: "()"
    Block
       Source: "{ \n        require (wagers[msg.sender] > 0); \n        _; \n    }"
      ExpressionStatement
         Source: "require (wagers[msg.sender] > 0)"
        FunctionCall
           Type: tuple()
           Source: "require (wagers[msg.sender] > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "wagers[msg.sender] > 0"
            IndexAccess
               Type: uint256
               Source: "wagers[msg.sender]"
              Identifier wagers
                 Type: mapping(address => uint256)
                 Source: "wagers"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      PlaceholderStatement
         Source: "_"
  EventDefinition "Wager"
     Source: "event Wager(uint256 amount, address depositer);"
    ParameterList
       Source: "(uint256 amount, address depositer)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "depositer"
         Type: address
         Source: "address depositer"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "Win"
     Source: "event Win(uint256 amount, address paidTo);"
    ParameterList
       Source: "(uint256 amount, address paidTo)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "paidTo"
         Type: address
         Source: "address paidTo"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "Lose"
     Source: "event Lose(uint256 amount, address loser);"
    ParameterList
       Source: "(uint256 amount, address loser)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "loser"
         Type: address
         Source: "address loser"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "Donate"
     Source: "event Donate(uint256 amount, address paidTo, address donator);"
    ParameterList
       Source: "(uint256 amount, address paidTo, address donator)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "paidTo"
         Type: address
         Source: "address paidTo"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "donator"
         Type: address
         Source: "address donator"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "DifficultyChanged"
     Source: "event DifficultyChanged(uint256 currentDifficulty);"
    ParameterList
       Source: "(uint256 currentDifficulty)"
      VariableDeclaration "currentDifficulty"
         Type: uint256
         Source: "uint256 currentDifficulty"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "BetLimitChanged"
     Source: "event BetLimitChanged(uint256 currentBetLimit);"
    ParameterList
       Source: "(uint256 currentBetLimit)"
      VariableDeclaration "currentBetLimit"
         Type: uint256
         Source: "uint256 currentBetLimit"
        ElementaryTypeName uint256
           Source: "uint256"
  VariableDeclaration "whale"
     Type: address
     Source: "address private whale"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "betLimit"
     Type: uint256
     Source: "uint256 betLimit"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "difficulty"
     Type: uint256
     Source: "uint difficulty"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "randomSeed"
     Type: uint256
     Source: "uint private randomSeed"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "owner"
     Type: address
     Source: "address owner"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "timestamps"
     Type: mapping(address => uint256)
     Source: "mapping(address => uint256) timestamps"
    Mapping
       Source: "mapping(address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "wagers"
     Type: mapping(address => uint256)
     Source: "mapping(address => uint256) wagers"
    Mapping
       Source: "mapping(address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "openToPublic"
     Type: bool
     Source: "bool openToPublic"
    ElementaryTypeName bool
       Source: "bool"
  VariableDeclaration "totalDonated"
     Type: uint256
     Source: "uint256 totalDonated"
    ElementaryTypeName uint256
       Source: "uint256"
  FunctionDefinition "" - public
     Source: "constructor(address whaleAddress, uint256 wagerLimit) \n    onlyRealPeople()\n    public \n    {\n        openToPublic = false;\n        owner = msg.sender;\n        whale = whaleAddress;\n        totalDonated = 0;\n        betLimit = wagerLimit;\n        \n    }"
    ParameterList
       Source: "(address whaleAddress, uint256 wagerLimit)"
      VariableDeclaration "whaleAddress"
         Type: address
         Source: "address whaleAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "wagerLimit"
         Type: uint256
         Source: "uint256 wagerLimit"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
    ModifierInvocation "onlyRealPeople"
       Source: "onlyRealPeople()"
      Identifier onlyRealPeople
         Type: modifier ()
         Source: "onlyRealPeople"
    Block
       Source: "{\n        openToPublic = false;\n        owner = msg.sender;\n        whale = whaleAddress;\n        totalDonated = 0;\n        betLimit = wagerLimit;\n        \n    }"
      ExpressionStatement
         Source: "openToPublic = false"
        Assignment using operator =
           Type: bool
           Source: "openToPublic = false"
          Identifier openToPublic
             Type: bool
             Source: "openToPublic"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ExpressionStatement
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Source: "whale = whaleAddress"
        Assignment using operator =
           Type: address
           Source: "whale = whaleAddress"
          Identifier whale
             Type: address
             Source: "whale"
          Identifier whaleAddress
             Type: address
             Source: "whaleAddress"
      ExpressionStatement
         Source: "totalDonated = 0"
        Assignment using operator =
           Type: uint256
           Source: "totalDonated = 0"
          Identifier totalDonated
             Type: uint256
             Source: "totalDonated"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Source: "betLimit = wagerLimit"
        Assignment using operator =
           Type: uint256
           Source: "betLimit = wagerLimit"
          Identifier betLimit
             Type: uint256
             Source: "betLimit"
          Identifier wagerLimit
             Type: uint256
             Source: "wagerLimit"
  FunctionDefinition "OpenToThePublic" - public
     Source: "function OpenToThePublic() \n    onlyOwner()\n    public\n    {\n        openToPublic = true;\n    }"
    ParameterList
       Source: "()"
    ParameterList
       Source: ""
    ModifierInvocation "onlyOwner"
       Source: "onlyOwner()"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\n        openToPublic = true;\n    }"
      ExpressionStatement
         Source: "openToPublic = true"
        Assignment using operator =
           Type: bool
           Source: "openToPublic = true"
          Identifier openToPublic
             Type: bool
             Source: "openToPublic"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "AdjustBetAmounts" - public
     Source: "function AdjustBetAmounts(uint256 amount) \n    onlyOwner()\n    public\n    {\n        betLimit = amount;\n        \n        emit BetLimitChanged(betLimit);\n    }"
    ParameterList
       Source: "(uint256 amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
    ModifierInvocation "onlyOwner"
       Source: "onlyOwner()"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\n        betLimit = amount;\n        \n        emit BetLimitChanged(betLimit);\n    }"
      ExpressionStatement
         Source: "betLimit = amount"
        Assignment using operator =
           Type: uint256
           Source: "betLimit = amount"
          Identifier betLimit
             Type: uint256
             Source: "betLimit"
          Identifier amount
             Type: uint256
             Source: "amount"
      EmitStatement
         Source: "emit BetLimitChanged(betLimit)"
        FunctionCall
           Type: tuple()
           Source: "BetLimitChanged(betLimit)"
          Identifier BetLimitChanged
             Type: function (uint256)
             Source: "BetLimitChanged"
          Identifier betLimit
             Type: uint256
             Source: "betLimit"
  FunctionDefinition "AdjustDifficulty" - public
     Source: "function AdjustDifficulty(uint256 amount) \n    onlyOwner()\n    public\n    {\n        difficulty = amount;\n        \n        emit DifficultyChanged(difficulty);\n    }"
    ParameterList
       Source: "(uint256 amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
    ModifierInvocation "onlyOwner"
       Source: "onlyOwner()"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\n        difficulty = amount;\n        \n        emit DifficultyChanged(difficulty);\n    }"
      ExpressionStatement
         Source: "difficulty = amount"
        Assignment using operator =
           Type: uint256
           Source: "difficulty = amount"
          Identifier difficulty
             Type: uint256
             Source: "difficulty"
          Identifier amount
             Type: uint256
             Source: "amount"
      EmitStatement
         Source: "emit DifficultyChanged(difficulty)"
        FunctionCall
           Type: tuple()
           Source: "DifficultyChanged(difficulty)"
          Identifier DifficultyChanged
             Type: function (uint256)
             Source: "DifficultyChanged"
          Identifier difficulty
             Type: uint256
             Source: "difficulty"
  FunctionDefinition "" - public
     Source: "function() public payable { }"
    ParameterList
       Source: "()"
    ParameterList
       Source: ""
    Block
       Source: "{ }"
  FunctionDefinition "wager" - public
     Source: "function wager()\n    isOpenToPublic()\n    onlyRealPeople() \n    payable\n    public \n    {\n        //You have to send exactly 0.01 ETH.\n        require(msg.value == betLimit);\n\n        //log the wager and timestamp(block number)\n        timestamps[msg.sender] = block.number;\n        wagers[msg.sender] = msg.value;\n        emit Wager(msg.value, msg.sender);\n    }"
    ParameterList
       Source: "()"
    ParameterList
       Source: ""
    ModifierInvocation "isOpenToPublic"
       Source: "isOpenToPublic()"
      Identifier isOpenToPublic
         Type: modifier ()
         Source: "isOpenToPublic"
    ModifierInvocation "onlyRealPeople"
       Source: "onlyRealPeople()"
      Identifier onlyRealPeople
         Type: modifier ()
         Source: "onlyRealPeople"
    Block
       Source: "{\n        //You have to send exactly 0.01 ETH.\n        require(msg.value == betLimit);\n\n        //log the wager and timestamp(block number)\n        timestamps[msg.sender] = block.number;\n        wagers[msg.sender] = msg.value;\n        emit Wager(msg.value, msg.sender);\n    }"
      ExpressionStatement
         Source: "require(msg.value == betLimit)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.value == betLimit)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.value == betLimit"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier betLimit
               Type: uint256
               Source: "betLimit"
      ExpressionStatement
         Source: "timestamps[msg.sender] = block.number"
        Assignment using operator =
           Type: uint256
           Source: "timestamps[msg.sender] = block.number"
          IndexAccess
             Type: uint256
             Source: "timestamps[msg.sender]"
            Identifier timestamps
               Type: mapping(address => uint256)
               Source: "timestamps"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
      ExpressionStatement
         Source: "wagers[msg.sender] = msg.value"
        Assignment using operator =
           Type: uint256
           Source: "wagers[msg.sender] = msg.value"
          IndexAccess
             Type: uint256
             Source: "wagers[msg.sender]"
            Identifier wagers
               Type: mapping(address => uint256)
               Source: "wagers"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
      EmitStatement
         Source: "emit Wager(msg.value, msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "Wager(msg.value, msg.sender)"
          Identifier Wager
             Type: function (uint256,address)
             Source: "Wager"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "play" - public
     Source: "function play()\n    isOpenToPublic()\n    onlyRealPeople()\n    onlyPlayers()\n    public\n    {\n        uint256 blockNumber = timestamps[msg.sender];\n        if(blockNumber < block.number)\n        {\n            timestamps[msg.sender] = 0;\n            wagers[msg.sender] = 0;\n    \n            uint256 winningNumber = uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  msg.sender)))%difficulty +1;\n    \n            if(winningNumber == difficulty / 2)\n            {\n                payout(msg.sender);\n            }\n            else \n            {\n                //player loses\n                loseWager(betLimit / 2);\n            }    \n        }\n        else\n        {\n            revert();\n        }\n    }"
    ParameterList
       Source: "()"
    ParameterList
       Source: ""
    ModifierInvocation "isOpenToPublic"
       Source: "isOpenToPublic()"
      Identifier isOpenToPublic
         Type: modifier ()
         Source: "isOpenToPublic"
    ModifierInvocation "onlyRealPeople"
       Source: "onlyRealPeople()"
      Identifier onlyRealPeople
         Type: modifier ()
         Source: "onlyRealPeople"
    ModifierInvocation "onlyPlayers"
       Source: "onlyPlayers()"
      Identifier onlyPlayers
         Type: modifier ()
         Source: "onlyPlayers"
    Block
       Source: "{\n        uint256 blockNumber = timestamps[msg.sender];\n        if(blockNumber < block.number)\n        {\n            timestamps[msg.sender] = 0;\n            wagers[msg.sender] = 0;\n    \n            uint256 winningNumber = uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  msg.sender)))%difficulty +1;\n    \n            if(winningNumber == difficulty / 2)\n            {\n                payout(msg.sender);\n            }\n            else \n            {\n                //player loses\n                loseWager(betLimit / 2);\n            }    \n        }\n        else\n        {\n            revert();\n        }\n    }"
      VariableDeclarationStatement
         Source: "uint256 blockNumber = timestamps[msg.sender]"
        VariableDeclaration "blockNumber"
           Type: uint256
           Source: "uint256 blockNumber"
          ElementaryTypeName uint256
             Source: "uint256"
        IndexAccess
           Type: uint256
           Source: "timestamps[msg.sender]"
          Identifier timestamps
             Type: mapping(address => uint256)
             Source: "timestamps"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      IfStatement
         Source: "if(blockNumber < block.number)\n        {\n            timestamps[msg.sender] = 0;\n            wagers[msg.sender] = 0;\n    \n            uint256 winningNumber = uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  msg.sender)))%difficulty +1;\n    \n            if(winningNumber == difficulty / 2)\n            {\n                payout(msg.sender);\n            }\n            else \n            {\n                //player loses\n                loseWager(betLimit / 2);\n            }    \n        }\n        else\n        {\n            revert();\n        }"
        BinaryOperation using operator <
           Type: bool
           Source: "blockNumber < block.number"
          Identifier blockNumber
             Type: uint256
             Source: "blockNumber"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
        Block
           Source: "{\n            timestamps[msg.sender] = 0;\n            wagers[msg.sender] = 0;\n    \n            uint256 winningNumber = uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  msg.sender)))%difficulty +1;\n    \n            if(winningNumber == difficulty / 2)\n            {\n                payout(msg.sender);\n            }\n            else \n            {\n                //player loses\n                loseWager(betLimit / 2);\n            }    \n        }"
          ExpressionStatement
             Source: "timestamps[msg.sender] = 0"
            Assignment using operator =
               Type: uint256
               Source: "timestamps[msg.sender] = 0"
              IndexAccess
                 Type: uint256
                 Source: "timestamps[msg.sender]"
                Identifier timestamps
                   Type: mapping(address => uint256)
                   Source: "timestamps"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          ExpressionStatement
             Source: "wagers[msg.sender] = 0"
            Assignment using operator =
               Type: uint256
               Source: "wagers[msg.sender] = 0"
              IndexAccess
                 Type: uint256
                 Source: "wagers[msg.sender]"
                Identifier wagers
                   Type: mapping(address => uint256)
                   Source: "wagers"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          VariableDeclarationStatement
             Source: "uint256 winningNumber = uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  msg.sender)))%difficulty +1"
            VariableDeclaration "winningNumber"
               Type: uint256
               Source: "uint256 winningNumber"
              ElementaryTypeName uint256
                 Source: "uint256"
            BinaryOperation using operator +
               Type: uint256
               Source: "uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  msg.sender)))%difficulty +1"
              BinaryOperation using operator %
                 Type: uint256
                 Source: "uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  msg.sender)))%difficulty"
                FunctionCall
                   Type: uint256
                   Source: "uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  msg.sender)))"
                  ElementaryTypeNameExpression uint256
                     Type: type(uint256)
                     Source: "uint256"
                  FunctionCall
                     Type: bytes32
                     Source: "keccak256(abi.encodePacked(blockhash(blockNumber),  msg.sender))"
                    Identifier keccak256
                       Type: function () pure returns (bytes32)
                       Source: "keccak256"
                    FunctionCall
                       Type: bytes memory
                       Source: "abi.encodePacked(blockhash(blockNumber),  msg.sender)"
                      MemberAccess to member encodePacked
                         Type: function () pure returns (bytes memory)
                         Source: "abi.encodePacked"
                        Identifier abi
                           Type: abi
                           Source: "abi"
                      FunctionCall
                         Type: bytes32
                         Source: "blockhash(blockNumber)"
                        Identifier blockhash
                           Type: function (uint256) view returns (bytes32)
                           Source: "blockhash"
                        Identifier blockNumber
                           Type: uint256
                           Source: "blockNumber"
                      MemberAccess to member sender
                         Type: address
                         Source: "msg.sender"
                        Identifier msg
                           Type: msg
                           Source: "msg"
                Identifier difficulty
                   Type: uint256
                   Source: "difficulty"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
          IfStatement
             Source: "if(winningNumber == difficulty / 2)\n            {\n                payout(msg.sender);\n            }\n            else \n            {\n                //player loses\n                loseWager(betLimit / 2);\n            }"
            BinaryOperation using operator ==
               Type: bool
               Source: "winningNumber == difficulty / 2"
              Identifier winningNumber
                 Type: uint256
                 Source: "winningNumber"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "difficulty / 2"
                Identifier difficulty
                   Type: uint256
                   Source: "difficulty"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
            Block
               Source: "{\n                payout(msg.sender);\n            }"
              ExpressionStatement
                 Source: "payout(msg.sender)"
                FunctionCall
                   Type: tuple()
                   Source: "payout(msg.sender)"
                  Identifier payout
                     Type: function (address)
                     Source: "payout"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
            Block
               Source: "{\n                //player loses\n                loseWager(betLimit / 2);\n            }"
              ExpressionStatement
                 Source: "loseWager(betLimit / 2)"
                FunctionCall
                   Type: tuple()
                   Source: "loseWager(betLimit / 2)"
                  Identifier loseWager
                     Type: function (uint256)
                     Source: "loseWager"
                  BinaryOperation using operator /
                     Type: uint256
                     Source: "betLimit / 2"
                    Identifier betLimit
                       Type: uint256
                       Source: "betLimit"
                    Literal, token: [no token] value: 2
                       Type: int_const 2
                       Source: "2"
        Block
           Source: "{\n            revert();\n        }"
          ExpressionStatement
             Source: "revert()"
            FunctionCall
               Type: tuple()
               Source: "revert()"
              Identifier revert
                 Type: function () pure
                 Source: "revert"
  FunctionDefinition "donate" - public
     Source: "function donate()\n    isOpenToPublic()\n    public \n    payable\n    {\n        donateToWhale(msg.value);\n    }"
    ParameterList
       Source: "()"
    ParameterList
       Source: ""
    ModifierInvocation "isOpenToPublic"
       Source: "isOpenToPublic()"
      Identifier isOpenToPublic
         Type: modifier ()
         Source: "isOpenToPublic"
    Block
       Source: "{\n        donateToWhale(msg.value);\n    }"
      ExpressionStatement
         Source: "donateToWhale(msg.value)"
        FunctionCall
           Type: tuple()
           Source: "donateToWhale(msg.value)"
          Identifier donateToWhale
             Type: function (uint256)
             Source: "donateToWhale"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "payout"
     Source: "function payout(address winner) \n    internal \n    {\n        uint256 ethToTransfer = address(this).balance / 2;\n        \n        winner.transfer(ethToTransfer);\n        emit Win(ethToTransfer, winner);\n    }"
    ParameterList
       Source: "(address winner)"
      VariableDeclaration "winner"
         Type: address
         Source: "address winner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: ""
    Block
       Source: "{\n        uint256 ethToTransfer = address(this).balance / 2;\n        \n        winner.transfer(ethToTransfer);\n        emit Win(ethToTransfer, winner);\n    }"
      VariableDeclarationStatement
         Source: "uint256 ethToTransfer = address(this).balance / 2"
        VariableDeclaration "ethToTransfer"
           Type: uint256
           Source: "uint256 ethToTransfer"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator /
           Type: uint256
           Source: "address(this).balance / 2"
          MemberAccess to member balance
             Type: uint256
             Source: "address(this).balance"
            FunctionCall
               Type: address
               Source: "address(this)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Identifier this
                 Type: contract PoCGame
                 Source: "this"
          Literal, token: [no token] value: 2
             Type: int_const 2
             Source: "2"
      ExpressionStatement
         Source: "winner.transfer(ethToTransfer)"
        FunctionCall
           Type: tuple()
           Source: "winner.transfer(ethToTransfer)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "winner.transfer"
            Identifier winner
               Type: address
               Source: "winner"
          Identifier ethToTransfer
             Type: uint256
             Source: "ethToTransfer"
      EmitStatement
         Source: "emit Win(ethToTransfer, winner)"
        FunctionCall
           Type: tuple()
           Source: "Win(ethToTransfer, winner)"
          Identifier Win
             Type: function (uint256,address)
             Source: "Win"
          Identifier ethToTransfer
             Type: uint256
             Source: "ethToTransfer"
          Identifier winner
             Type: address
             Source: "winner"
  FunctionDefinition "donateToWhale"
     Source: "function donateToWhale(uint256 amount) \n    internal \n    {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        whale.call.value(amount)(bytes4(keccak256(\"donate()\")));\n        totalDonated += amount;\n        emit Donate(amount, whale, msg.sender);\n    }"
    ParameterList
       Source: "(uint256 amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
    Block
       Source: "{\n        // <yes> <report> UNCHECKED_LL_CALLS\n        whale.call.value(amount)(bytes4(keccak256(\"donate()\")));\n        totalDonated += amount;\n        emit Donate(amount, whale, msg.sender);\n    }"
      ExpressionStatement
         Source: "whale.call.value(amount)(bytes4(keccak256(\"donate()\")))"
        FunctionCall
           Type: bool
           Source: "whale.call.value(amount)(bytes4(keccak256(\"donate()\")))"
          FunctionCall
             Type: function () payable returns (bool)
             Source: "whale.call.value(amount)"
            MemberAccess to member value
               Type: function (uint256) returns (function () payable returns (bool))
               Source: "whale.call.value"
              MemberAccess to member call
                 Type: function () payable returns (bool)
                 Source: "whale.call"
                Identifier whale
                   Type: address
                   Source: "whale"
            Identifier amount
               Type: uint256
               Source: "amount"
          FunctionCall
             Type: bytes4
             Source: "bytes4(keccak256(\"donate()\"))"
            ElementaryTypeNameExpression bytes4
               Type: type(bytes4)
               Source: "bytes4"
            FunctionCall
               Type: bytes32
               Source: "keccak256(\"donate()\")"
              Identifier keccak256
                 Type: function () pure returns (bytes32)
                 Source: "keccak256"
              Literal, token: [no token] value: donate()
                 Type: literal_string "donate()"
                 Source: "\"donate()\""
      ExpressionStatement
         Source: "totalDonated += amount"
        Assignment using operator +=
           Type: uint256
           Source: "totalDonated += amount"
          Identifier totalDonated
             Type: uint256
             Source: "totalDonated"
          Identifier amount
             Type: uint256
             Source: "amount"
      EmitStatement
         Source: "emit Donate(amount, whale, msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "Donate(amount, whale, msg.sender)"
          Identifier Donate
             Type: function (uint256,address,address)
             Source: "Donate"
          Identifier amount
             Type: uint256
             Source: "amount"
          Identifier whale
             Type: address
             Source: "whale"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "loseWager"
     Source: "function loseWager(uint256 amount) \n    internal \n    {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        whale.call.value(amount)(bytes4(keccak256(\"donate()\")));\n        totalDonated += amount;\n        emit Lose(amount, msg.sender);\n    }"
    ParameterList
       Source: "(uint256 amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
    Block
       Source: "{\n        // <yes> <report> UNCHECKED_LL_CALLS\n        whale.call.value(amount)(bytes4(keccak256(\"donate()\")));\n        totalDonated += amount;\n        emit Lose(amount, msg.sender);\n    }"
      ExpressionStatement
         Source: "whale.call.value(amount)(bytes4(keccak256(\"donate()\")))"
        FunctionCall
           Type: bool
           Source: "whale.call.value(amount)(bytes4(keccak256(\"donate()\")))"
          FunctionCall
             Type: function () payable returns (bool)
             Source: "whale.call.value(amount)"
            MemberAccess to member value
               Type: function (uint256) returns (function () payable returns (bool))
               Source: "whale.call.value"
              MemberAccess to member call
                 Type: function () payable returns (bool)
                 Source: "whale.call"
                Identifier whale
                   Type: address
                   Source: "whale"
            Identifier amount
               Type: uint256
               Source: "amount"
          FunctionCall
             Type: bytes4
             Source: "bytes4(keccak256(\"donate()\"))"
            ElementaryTypeNameExpression bytes4
               Type: type(bytes4)
               Source: "bytes4"
            FunctionCall
               Type: bytes32
               Source: "keccak256(\"donate()\")"
              Identifier keccak256
                 Type: function () pure returns (bytes32)
                 Source: "keccak256"
              Literal, token: [no token] value: donate()
                 Type: literal_string "donate()"
                 Source: "\"donate()\""
      ExpressionStatement
         Source: "totalDonated += amount"
        Assignment using operator +=
           Type: uint256
           Source: "totalDonated += amount"
          Identifier totalDonated
             Type: uint256
             Source: "totalDonated"
          Identifier amount
             Type: uint256
             Source: "amount"
      EmitStatement
         Source: "emit Lose(amount, msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "Lose(amount, msg.sender)"
          Identifier Lose
             Type: function (uint256,address)
             Source: "Lose"
          Identifier amount
             Type: uint256
             Source: "amount"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "ethBalance" - public - const
     Source: "function ethBalance() \n    public \n    view \n    returns (uint256)\n    {\n        return address(this).balance;\n    }"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\n        return address(this).balance;\n    }"
      Return
         Source: "return address(this).balance"
        MemberAccess to member balance
           Type: uint256
           Source: "address(this).balance"
          FunctionCall
             Type: address
             Source: "address(this)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Identifier this
               Type: contract PoCGame
               Source: "this"
  FunctionDefinition "currentDifficulty" - public - const
     Source: "function currentDifficulty() \n    public \n    view \n    returns (uint256)\n    {\n        return difficulty;\n    }"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\n        return difficulty;\n    }"
      Return
         Source: "return difficulty"
        Identifier difficulty
           Type: uint256
           Source: "difficulty"
  FunctionDefinition "currentBetLimit" - public - const
     Source: "function currentBetLimit() \n    public \n    view \n    returns (uint256)\n    {\n        return betLimit;\n    }"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\n        return betLimit;\n    }"
      Return
         Source: "return betLimit"
        Identifier betLimit
           Type: uint256
           Source: "betLimit"
  FunctionDefinition "hasPlayerWagered" - public - const
     Source: "function hasPlayerWagered(address player)\n    public \n    view \n    returns (bool)\n    {\n        if(wagers[player] > 0)\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n        \n    }"
    ParameterList
       Source: "(address player)"
      VariableDeclaration "player"
         Type: address
         Source: "address player"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        if(wagers[player] > 0)\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n        \n    }"
      IfStatement
         Source: "if(wagers[player] > 0)\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }"
        BinaryOperation using operator >
           Type: bool
           Source: "wagers[player] > 0"
          IndexAccess
             Type: uint256
             Source: "wagers[player]"
            Identifier wagers
               Type: mapping(address => uint256)
               Source: "wagers"
            Identifier player
               Type: address
               Source: "player"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\n            return true;\n        }"
          Return
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
        Block
           Source: "{\n            return false;\n        }"
          Return
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
  FunctionDefinition "winnersPot" - public - const
     Source: "function winnersPot() \n    public \n    view \n    returns (uint256)\n    {\n        return address(this).balance / 2;\n    }"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\n        return address(this).balance / 2;\n    }"
      Return
         Source: "return address(this).balance / 2"
        BinaryOperation using operator /
           Type: uint256
           Source: "address(this).balance / 2"
          MemberAccess to member balance
             Type: uint256
             Source: "address(this).balance"
            FunctionCall
               Type: address
               Source: "address(this)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Identifier this
                 Type: contract PoCGame
                 Source: "this"
          Literal, token: [no token] value: 2
             Type: int_const 2
             Source: "2"
  FunctionDefinition "transferAnyERC20Token" - public
     Source: "function transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens) \n    public \n    onlyOwner() \n    returns (bool success) \n    {\n        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n    }"
    ParameterList
       Source: "(address tokenAddress, address tokenOwner, uint tokens)"
      VariableDeclaration "tokenAddress"
         Type: address
         Source: "address tokenAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "tokenOwner"
         Type: address
         Source: "address tokenOwner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "tokens"
         Type: uint256
         Source: "uint tokens"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyOwner"
       Source: "onlyOwner()"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\n        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n    }"
      Return
         Source: "return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens)"
        FunctionCall
           Type: bool
           Source: "ERC20Interface(tokenAddress).transfer(tokenOwner, tokens)"
          MemberAccess to member transfer
             Type: function (address,uint256) external returns (bool)
             Source: "ERC20Interface(tokenAddress).transfer"
            FunctionCall
               Type: contract ERC20Interface
               Source: "ERC20Interface(tokenAddress)"
              Identifier ERC20Interface
                 Type: type(contract ERC20Interface)
                 Source: "ERC20Interface"
              Identifier tokenAddress
                 Type: address
                 Source: "tokenAddress"
          Identifier tokenOwner
             Type: address
             Source: "tokenOwner"
          Identifier tokens
             Type: uint256
             Source: "tokens"
ContractDefinition "ERC20Interface"
   Source: "contract ERC20Interface \n{\n    function transfer(address to, uint256 tokens) public returns (bool success);\n}"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address to, uint256 tokens) public returns (bool success);"
    ParameterList
       Source: "(address to, uint256 tokens)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "tokens"
         Type: uint256
         Source: "uint256 tokens"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
