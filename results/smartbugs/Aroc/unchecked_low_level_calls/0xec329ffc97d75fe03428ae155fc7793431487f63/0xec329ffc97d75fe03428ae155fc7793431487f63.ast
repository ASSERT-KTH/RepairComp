Syntax trees:


======= /smartbugs-curated/dataset/unchecked_low_level_calls/0xec329ffc97d75fe03428ae155fc7793431487f63.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.11;"
ContractDefinition "Owned"
   Source: "contract Owned {\n    function Owned() {\n        owner = msg.sender;\n    }\n\n    address public owner;\n\n    // This contract only defines a modifier and a few useful functions\n    // The function body is inserted where the special symbol \"_\" in the\n    // definition of a modifier appears.\n    modifier onlyOwner { if (msg.sender == owner) _; }\n\n    function changeOwner(address _newOwner) onlyOwner {\n        owner = _newOwner;\n    }\n\n    // This is a general safty function that allows the owner to do a lot\n    //  of things in the unlikely event that something goes wrong\n    // _dst is the contract being called making this like a 1/1 multisig\n    function execute(address _dst, uint _value, bytes _data) onlyOwner {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        _dst.call.value(_value)(_data);\n    }\n}"
  FunctionDefinition "Owned" - public
     Source: "function Owned() {\n        owner = msg.sender;\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n        owner = msg.sender;\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  VariableDeclaration "owner"
     Type: address
     Gas costs: 335
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner { if (msg.sender == owner) _; }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{ if (msg.sender == owner) _; }"
      IfStatement
         Source: "if (msg.sender == owner) _"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 1024
           Source: "msg.sender == owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier owner
             Type: address
             Source: "owner"
        PlaceholderStatement
           Gas costs: 1
           Source: "_"
  FunctionDefinition "changeOwner" - public
     Source: "function changeOwner(address _newOwner) onlyOwner {\n        owner = _newOwner;\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _newOwner)"
      VariableDeclaration "_newOwner"
         Type: address
         Source: "address _newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\n        owner = _newOwner;\n    }"
      ExpressionStatement
         Gas costs: 20267
         Source: "owner = _newOwner"
        Assignment using operator =
           Type: address
           Source: "owner = _newOwner"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier _newOwner
             Type: address
             Source: "_newOwner"
  FunctionDefinition "execute" - public
     Source: "function execute(address _dst, uint _value, bytes _data) onlyOwner {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        _dst.call.value(_value)(_data);\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _dst, uint _value, bytes _data)"
      VariableDeclaration "_dst"
         Type: address
         Source: "address _dst"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_data"
         Type: bytes memory
         Source: "bytes _data"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\n        // <yes> <report> UNCHECKED_LL_CALLS\n        _dst.call.value(_value)(_data);\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "_dst.call.value(_value)(_data)"
        FunctionCall
           Type: bool
           Source: "_dst.call.value(_value)(_data)"
          FunctionCall
             Type: function () payable returns (bool)
             Source: "_dst.call.value(_value)"
            MemberAccess to member value
               Type: function (uint256) returns (function () payable returns (bool))
               Source: "_dst.call.value"
              MemberAccess to member call
                 Type: function () payable returns (bool)
                 Source: "_dst.call"
                Identifier _dst
                   Type: address
                   Source: "_dst"
            Identifier _value
               Type: uint256
               Source: "_value"
          Identifier _data
             Type: bytes memory
             Source: "_data"
ContractDefinition "Token"
   Gas costs: 0
   Source: "contract Token {\n    function transfer(address, uint) returns(bool);\n    function balanceOf(address) constant returns (uint);\n}"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address, uint) returns(bool);"
    ParameterList
       Source: "(address, uint)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address) constant returns (uint);"
    ParameterList
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
ContractDefinition "TokenSender"
   Source: "contract TokenSender is Owned {\n    Token public token; // the token we are working with\n    uint public totalToDistribute;\n\n    uint public next;\n\n\n    struct Transfer {\n        address addr;\n        uint amount;\n    }\n\n    Transfer[] public transfers;\n\n    function TokenSender(address _token) {\n        token = Token(_token);\n    }\n\n    // this is a used to save gas\n    uint constant D160 = 0x0010000000000000000000000000000000000000000;\n\n    // This is the function that makes the list of transfers and various\n    //  checks around that list, it is a little tricky, the data input is\n    //  structured with the `amount` and the (receiving) `addr` combined as one\n    //  long number and then this number is deconstructed in this function to\n    //  save gas and reduce the number of `0`'s that are needed to be stored\n    //   on the blockchain\n    function fill(uint[] data) onlyOwner {\n\n        // If the send has started then we just throw\n        if (next>0) throw;\n\n        uint acc;\n        uint offset = transfers.length;\n        transfers.length = transfers.length + data.length;\n        for (uint i = 0; i < data.length; i++ ) {\n            address addr = address( data[i] & (D160-1) );\n            uint amount = data[i] / D160;\n\n            transfers[offset + i].addr = addr;\n            transfers[offset + i].amount = amount;\n            acc += amount;\n        }\n        totalToDistribute += acc;\n    }\n    // This function actually makes the sends and tracks the amount of gas used\n    //  if it takes more gas than was sent with the transaction then this\n    //  function will need to be called a few times until\n    function run() onlyOwner {\n        if (transfers.length == 0) return;\n\n        // Keep next in the stack var mNext to save gas\n        uint mNext = next;\n\n        // Set the contract as finalized to avoid reentrance\n        next = transfers.length;\n\n        if ((mNext == 0 ) && ( token.balanceOf(this) != totalToDistribute)) throw;\n\n        while ((mNext<transfers.length) && ( gas() > 150000 )) {\n            uint amount = transfers[mNext].amount;\n            address addr = transfers[mNext].addr;\n            if (amount > 0) {\n                if (!token.transfer(addr, transfers[mNext].amount)) throw;\n            }\n            mNext ++;\n        }\n\n        // Set the next to the actual state.\n        next = mNext;\n    }\n\n\n    ///////////////////////\n    // Helper functions\n    ///////////////////////\n\n    function hasTerminated() constant returns (bool) {\n        if (transfers.length == 0) return false;\n        if (next < transfers.length) return false;\n        return true;\n    }\n\n    function nTransfers() constant returns (uint) {\n        return transfers.length;\n    }\n\n    function gas() internal constant returns (uint _gas) {\n        assembly {\n            _gas:= gas\n        }\n    }\n\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Owned"
    UserDefinedTypeName "Owned"
       Source: "Owned"
  VariableDeclaration "token"
     Type: contract Token
     Gas costs: 335
     Source: "Token public token"
    UserDefinedTypeName "Token"
       Source: "Token"
  VariableDeclaration "totalToDistribute"
     Type: uint256
     Gas costs: 287
     Source: "uint public totalToDistribute"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "next"
     Type: uint256
     Gas costs: 287
     Source: "uint public next"
    ElementaryTypeName uint
       Source: "uint"
  StructDefinition "Transfer"
     Gas costs: 0
     Source: "struct Transfer {\n        address addr;\n        uint amount;\n    }"
    VariableDeclaration "addr"
       Type: address
       Source: "address addr"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "amount"
       Type: uint256
       Source: "uint amount"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "transfers"
     Type: struct TokenSender.Transfer storage ref[] storage ref
     Gas costs: 950
     Source: "Transfer[] public transfers"
    ArrayTypeName
       Source: "Transfer[]"
      UserDefinedTypeName "Transfer"
         Source: "Transfer"
  FunctionDefinition "TokenSender" - public
     Source: "function TokenSender(address _token) {\n        token = Token(_token);\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _token)"
      VariableDeclaration "_token"
         Type: address
         Source: "address _token"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n        token = Token(_token);\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "token = Token(_token)"
        Assignment using operator =
           Type: contract Token
           Source: "token = Token(_token)"
          Identifier token
             Type: contract Token
             Source: "token"
          FunctionCall
             Type: contract Token
             Source: "Token(_token)"
            Identifier Token
               Type: type(contract Token)
               Source: "Token"
            Identifier _token
               Type: address
               Source: "_token"
  VariableDeclaration "D160"
     Type: uint256
     Gas costs: 6
     Source: "uint constant D160 = 0x0010000000000000000000000000000000000000000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0x0010000000000000000000000000000000000000000
       Type: int_const 1461...(41 digits omitted)...2976
       Source: "0x0010000000000000000000000000000000000000000"
  FunctionDefinition "fill" - public
     Source: "function fill(uint[] data) onlyOwner {\n\n        // If the send has started then we just throw\n        if (next>0) throw;\n\n        uint acc;\n        uint offset = transfers.length;\n        transfers.length = transfers.length + data.length;\n        for (uint i = 0; i < data.length; i++ ) {\n            address addr = address( data[i] & (D160-1) );\n            uint amount = data[i] / D160;\n\n            transfers[offset + i].addr = addr;\n            transfers[offset + i].amount = amount;\n            acc += amount;\n        }\n        totalToDistribute += acc;\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint[] data)"
      VariableDeclaration "data"
         Type: uint256[] memory
         Source: "uint[] data"
        ArrayTypeName
           Source: "uint[]"
          ElementaryTypeName uint
             Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\n\n        // If the send has started then we just throw\n        if (next>0) throw;\n\n        uint acc;\n        uint offset = transfers.length;\n        transfers.length = transfers.length + data.length;\n        for (uint i = 0; i < data.length; i++ ) {\n            address addr = address( data[i] & (D160-1) );\n            uint amount = data[i] / D160;\n\n            transfers[offset + i].addr = addr;\n            transfers[offset + i].amount = amount;\n            acc += amount;\n        }\n        totalToDistribute += acc;\n    }"
      IfStatement
         Source: "if (next>0) throw"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 209
           Source: "next>0"
          Identifier next
             Type: uint256
             Source: "next"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 6
           Source: "throw"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "uint acc"
        VariableDeclaration "acc"
           Type: uint256
           Source: "uint acc"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Gas costs: 219
         Source: "uint offset = transfers.length"
        VariableDeclaration "offset"
           Type: uint256
           Source: "uint offset"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member length
           Type: uint256
           Source: "transfers.length"
          Identifier transfers
             Type: struct TokenSender.Transfer storage ref[] storage ref
             Source: "transfers"
      ExpressionStatement
         Gas costs: 253
         Source: "transfers.length = transfers.length + data.length"
        Assignment using operator =
           Type: uint256
           Source: "transfers.length = transfers.length + data.length"
          MemberAccess to member length
             Type: uint256
             Source: "transfers.length"
            Identifier transfers
               Type: struct TokenSender.Transfer storage ref[] storage ref
               Source: "transfers"
          BinaryOperation using operator +
             Type: uint256
             Source: "transfers.length + data.length"
            MemberAccess to member length
               Type: uint256
               Source: "transfers.length"
              Identifier transfers
                 Type: struct TokenSender.Transfer storage ref[] storage ref
                 Source: "transfers"
            MemberAccess to member length
               Type: uint256
               Source: "data.length"
              Identifier data
                 Type: uint256[] memory
                 Source: "data"
      ForStatement
         Source: "for (uint i = 0; i < data.length; i++ ) {\n            address addr = address( data[i] & (D160-1) );\n            uint amount = data[i] / D160;\n\n            transfers[offset + i].addr = addr;\n            transfers[offset + i].amount = amount;\n            acc += amount;\n        }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 27
           Source: "i < data.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "data.length"
            Identifier data
               Type: uint256[] memory
               Source: "data"
        ExpressionStatement
           Gas costs: 19
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\n            address addr = address( data[i] & (D160-1) );\n            uint amount = data[i] / D160;\n\n            transfers[offset + i].addr = addr;\n            transfers[offset + i].amount = amount;\n            acc += amount;\n        }"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "address addr = address( data[i] & (D160-1) )"
            VariableDeclaration "addr"
               Type: address
               Source: "address addr"
              ElementaryTypeName address
                 Source: "address"
            FunctionCall
               Type: address
               Source: "address( data[i] & (D160-1) )"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              BinaryOperation using operator &
                 Type: uint256
                 Source: "data[i] & (D160-1)"
                IndexAccess
                   Type: uint256
                   Source: "data[i]"
                  Identifier data
                     Type: uint256[] memory
                     Source: "data"
                  Identifier i
                     Type: uint256
                     Source: "i"
                TupleExpression
                   Type: uint256
                   Source: "(D160-1)"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "D160-1"
                    Identifier D160
                       Type: uint256
                       Source: "D160"
                    Literal, token: [no token] value: 1
                       Type: int_const 1
                       Source: "1"
          VariableDeclarationStatement
             Gas costs: [???]
             Source: "uint amount = data[i] / D160"
            VariableDeclaration "amount"
               Type: uint256
               Source: "uint amount"
              ElementaryTypeName uint
                 Source: "uint"
            BinaryOperation using operator /
               Type: uint256
               Source: "data[i] / D160"
              IndexAccess
                 Type: uint256
                 Source: "data[i]"
                Identifier data
                   Type: uint256[] memory
                   Source: "data"
                Identifier i
                   Type: uint256
                   Source: "i"
              Identifier D160
                 Type: uint256
                 Source: "D160"
          ExpressionStatement
             Gas costs: 20579
             Source: "transfers[offset + i].addr = addr"
            Assignment using operator =
               Type: address
               Source: "transfers[offset + i].addr = addr"
              MemberAccess to member addr
                 Type: address
                 Source: "transfers[offset + i].addr"
                IndexAccess
                   Type: struct TokenSender.Transfer storage ref
                   Source: "transfers[offset + i]"
                  Identifier transfers
                     Type: struct TokenSender.Transfer storage ref[] storage ref
                     Source: "transfers"
                  BinaryOperation using operator +
                     Type: uint256
                     Source: "offset + i"
                    Identifier offset
                       Type: uint256
                       Source: "offset"
                    Identifier i
                       Type: uint256
                       Source: "i"
              Identifier addr
                 Type: address
                 Source: "addr"
          ExpressionStatement
             Gas costs: 20326
             Source: "transfers[offset + i].amount = amount"
            Assignment using operator =
               Type: uint256
               Source: "transfers[offset + i].amount = amount"
              MemberAccess to member amount
                 Type: uint256
                 Source: "transfers[offset + i].amount"
                IndexAccess
                   Type: struct TokenSender.Transfer storage ref
                   Source: "transfers[offset + i]"
                  Identifier transfers
                     Type: struct TokenSender.Transfer storage ref[] storage ref
                     Source: "transfers"
                  BinaryOperation using operator +
                     Type: uint256
                     Source: "offset + i"
                    Identifier offset
                       Type: uint256
                       Source: "offset"
                    Identifier i
                       Type: uint256
                       Source: "i"
              Identifier amount
                 Type: uint256
                 Source: "amount"
          ExpressionStatement
             Gas costs: 14
             Source: "acc += amount"
            Assignment using operator +=
               Type: uint256
               Source: "acc += amount"
              Identifier acc
                 Type: uint256
                 Source: "acc"
              Identifier amount
                 Type: uint256
                 Source: "amount"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalToDistribute += acc"
        Assignment using operator +=
           Type: uint256
           Source: "totalToDistribute += acc"
          Identifier totalToDistribute
             Type: uint256
             Source: "totalToDistribute"
          Identifier acc
             Type: uint256
             Source: "acc"
  FunctionDefinition "run" - public
     Source: "function run() onlyOwner {\n        if (transfers.length == 0) return;\n\n        // Keep next in the stack var mNext to save gas\n        uint mNext = next;\n\n        // Set the contract as finalized to avoid reentrance\n        next = transfers.length;\n\n        if ((mNext == 0 ) && ( token.balanceOf(this) != totalToDistribute)) throw;\n\n        while ((mNext<transfers.length) && ( gas() > 150000 )) {\n            uint amount = transfers[mNext].amount;\n            address addr = transfers[mNext].addr;\n            if (amount > 0) {\n                if (!token.transfer(addr, transfers[mNext].amount)) throw;\n            }\n            mNext ++;\n        }\n\n        // Set the next to the actual state.\n        next = mNext;\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\n        if (transfers.length == 0) return;\n\n        // Keep next in the stack var mNext to save gas\n        uint mNext = next;\n\n        // Set the contract as finalized to avoid reentrance\n        next = transfers.length;\n\n        if ((mNext == 0 ) && ( token.balanceOf(this) != totalToDistribute)) throw;\n\n        while ((mNext<transfers.length) && ( gas() > 150000 )) {\n            uint amount = transfers[mNext].amount;\n            address addr = transfers[mNext].addr;\n            if (amount > 0) {\n                if (!token.transfer(addr, transfers[mNext].amount)) throw;\n            }\n            mNext ++;\n        }\n\n        // Set the next to the actual state.\n        next = mNext;\n    }"
      IfStatement
         Source: "if (transfers.length == 0) return;"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 217
           Source: "transfers.length == 0"
          MemberAccess to member length
             Type: uint256
             Source: "transfers.length"
            Identifier transfers
               Type: struct TokenSender.Transfer storage ref[] storage ref
               Source: "transfers"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 11
           Source: "return;"
      VariableDeclarationStatement
         Gas costs: 211
         Source: "uint mNext = next"
        VariableDeclaration "mNext"
           Type: uint256
           Source: "uint mNext"
          ElementaryTypeName uint
             Source: "uint"
        Identifier next
           Type: uint256
           Source: "next"
      ExpressionStatement
         Gas costs: 20222
         Source: "next = transfers.length"
        Assignment using operator =
           Type: uint256
           Source: "next = transfers.length"
          Identifier next
             Type: uint256
             Source: "next"
          MemberAccess to member length
             Type: uint256
             Source: "transfers.length"
            Identifier transfers
               Type: struct TokenSender.Transfer storage ref[] storage ref
               Source: "transfers"
      IfStatement
         Source: "if ((mNext == 0 ) && ( token.balanceOf(this) != totalToDistribute)) throw"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: [???]
           Source: "(mNext == 0 ) && ( token.balanceOf(this) != totalToDistribute)"
          TupleExpression
             Type: bool
             Source: "(mNext == 0 )"
            BinaryOperation using operator ==
               Type: bool
               Source: "mNext == 0"
              Identifier mNext
                 Type: uint256
                 Source: "mNext"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          TupleExpression
             Type: bool
             Source: "( token.balanceOf(this) != totalToDistribute)"
            BinaryOperation using operator !=
               Type: bool
               Source: "token.balanceOf(this) != totalToDistribute"
              FunctionCall
                 Type: uint256
                 Source: "token.balanceOf(this)"
                MemberAccess to member balanceOf
                   Type: function (address) view external returns (uint256)
                   Source: "token.balanceOf"
                  Identifier token
                     Type: contract Token
                     Source: "token"
                Identifier this
                   Type: contract TokenSender
                   Source: "this"
              Identifier totalToDistribute
                 Type: uint256
                 Source: "totalToDistribute"
        Throw
           Gas costs: 6
           Source: "throw"
      WhileStatement
         Source: "while ((mNext<transfers.length) && ( gas() > 150000 )) {\n            uint amount = transfers[mNext].amount;\n            address addr = transfers[mNext].addr;\n            if (amount > 0) {\n                if (!token.transfer(addr, transfers[mNext].amount)) throw;\n            }\n            mNext ++;\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 249
           Source: "(mNext<transfers.length) && ( gas() > 150000 )"
          TupleExpression
             Type: bool
             Source: "(mNext<transfers.length)"
            BinaryOperation using operator <
               Type: bool
               Source: "mNext<transfers.length"
              Identifier mNext
                 Type: uint256
                 Source: "mNext"
              MemberAccess to member length
                 Type: uint256
                 Source: "transfers.length"
                Identifier transfers
                   Type: struct TokenSender.Transfer storage ref[] storage ref
                   Source: "transfers"
          TupleExpression
             Type: bool
             Source: "( gas() > 150000 )"
            BinaryOperation using operator >
               Type: bool
               Source: "gas() > 150000"
              FunctionCall
                 Type: uint256
                 Source: "gas()"
                Identifier gas
                   Type: function () view returns (uint256)
                   Source: "gas"
              Literal, token: [no token] value: 150000
                 Type: int_const 150000
                 Source: "150000"
        Block
           Source: "{\n            uint amount = transfers[mNext].amount;\n            address addr = transfers[mNext].addr;\n            if (amount > 0) {\n                if (!token.transfer(addr, transfers[mNext].amount)) throw;\n            }\n            mNext ++;\n        }"
          VariableDeclarationStatement
             Gas costs: 517
             Source: "uint amount = transfers[mNext].amount"
            VariableDeclaration "amount"
               Type: uint256
               Source: "uint amount"
              ElementaryTypeName uint
                 Source: "uint"
            MemberAccess to member amount
               Type: uint256
               Source: "transfers[mNext].amount"
              IndexAccess
                 Type: struct TokenSender.Transfer storage ref
                 Source: "transfers[mNext]"
                Identifier transfers
                   Type: struct TokenSender.Transfer storage ref[] storage ref
                   Source: "transfers"
                Identifier mNext
                   Type: uint256
                   Source: "mNext"
          VariableDeclarationStatement
             Gas costs: 553
             Source: "address addr = transfers[mNext].addr"
            VariableDeclaration "addr"
               Type: address
               Source: "address addr"
              ElementaryTypeName address
                 Source: "address"
            MemberAccess to member addr
               Type: address
               Source: "transfers[mNext].addr"
              IndexAccess
                 Type: struct TokenSender.Transfer storage ref
                 Source: "transfers[mNext]"
                Identifier transfers
                   Type: struct TokenSender.Transfer storage ref[] storage ref
                   Source: "transfers"
                Identifier mNext
                   Type: uint256
                   Source: "mNext"
          IfStatement
             Source: "if (amount > 0) {\n                if (!token.transfer(addr, transfers[mNext].amount)) throw;\n            }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: 9
               Source: "amount > 0"
              Identifier amount
                 Type: uint256
                 Source: "amount"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Block
               Source: "{\n                if (!token.transfer(addr, transfers[mNext].amount)) throw;\n            }"
              IfStatement
                 Source: "if (!token.transfer(addr, transfers[mNext].amount)) throw"
                UnaryOperation (prefix) !
                   Type: bool
                   Gas costs: [???]
                   Source: "!token.transfer(addr, transfers[mNext].amount)"
                  FunctionCall
                     Type: bool
                     Source: "token.transfer(addr, transfers[mNext].amount)"
                    MemberAccess to member transfer
                       Type: function (address,uint256) external returns (bool)
                       Source: "token.transfer"
                      Identifier token
                         Type: contract Token
                         Source: "token"
                    Identifier addr
                       Type: address
                       Source: "addr"
                    MemberAccess to member amount
                       Type: uint256
                       Source: "transfers[mNext].amount"
                      IndexAccess
                         Type: struct TokenSender.Transfer storage ref
                         Source: "transfers[mNext]"
                        Identifier transfers
                           Type: struct TokenSender.Transfer storage ref[] storage ref
                           Source: "transfers"
                        Identifier mNext
                           Type: uint256
                           Source: "mNext"
                Throw
                   Gas costs: 6
                   Source: "throw"
          ExpressionStatement
             Gas costs: 19
             Source: "mNext ++"
            UnaryOperation (postfix) ++
               Type: uint256
               Source: "mNext ++"
              Identifier mNext
                 Type: uint256
                 Source: "mNext"
      ExpressionStatement
         Gas costs: 20014
         Source: "next = mNext"
        Assignment using operator =
           Type: uint256
           Source: "next = mNext"
          Identifier next
             Type: uint256
             Source: "next"
          Identifier mNext
             Type: uint256
             Source: "mNext"
  FunctionDefinition "hasTerminated" - public - const
     Source: "function hasTerminated() constant returns (bool) {\n        if (transfers.length == 0) return false;\n        if (next < transfers.length) return false;\n        return true;\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        if (transfers.length == 0) return false;\n        if (next < transfers.length) return false;\n        return true;\n    }"
      IfStatement
         Source: "if (transfers.length == 0) return false"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 217
           Source: "transfers.length == 0"
          MemberAccess to member length
             Type: uint256
             Source: "transfers.length"
            Identifier transfers
               Type: struct TokenSender.Transfer storage ref[] storage ref
               Source: "transfers"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 19
           Source: "return false"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      IfStatement
         Source: "if (next < transfers.length) return false"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 417
           Source: "next < transfers.length"
          Identifier next
             Type: uint256
             Source: "next"
          MemberAccess to member length
             Type: uint256
             Source: "transfers.length"
            Identifier transfers
               Type: struct TokenSender.Transfer storage ref[] storage ref
               Source: "transfers"
        Return
           Gas costs: 19
           Source: "return false"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "nTransfers" - public - const
     Source: "function nTransfers() constant returns (uint) {\n        return transfers.length;\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\n        return transfers.length;\n    }"
      Return
         Gas costs: 216
         Source: "return transfers.length"
        MemberAccess to member length
           Type: uint256
           Source: "transfers.length"
          Identifier transfers
             Type: struct TokenSender.Transfer storage ref[] storage ref
             Source: "transfers"
  FunctionDefinition "gas" - const
     Source: "function gas() internal constant returns (uint _gas) {\n        assembly {\n            _gas:= gas\n        }\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint _gas)"
      VariableDeclaration "_gas"
         Type: uint256
         Source: "uint _gas"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\n        assembly {\n            _gas:= gas\n        }\n    }"
      InlineAssembly
         Gas costs: 0
         Source: "assembly {\n            _gas:= gas\n        }\n    }"
